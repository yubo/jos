# labs2

## should browse file
```
inc/memlayout.h
kern/pmap.c
kern/pmap.h
kern/kclock.h
kern/kclock.c
```

## part 1: physical page management
```
git checkout -b lab2 origin/lab2
git merge lab1
```

#### Exercise 1. 
In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).

```
boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
```

check_page_free_list() and check_page_alloc() test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.

## part 2: virtual memory
#### Exercise 4. 
In the file kern/pmap.c, you must implement code for the following functions.
```
        pgdir_walk()
        boot_map_region()
        page_lookup()
        page_remove()
        page_insert()
```
check_page(), called from mem_init(), tests your page table management routines. You should make sure it reports success before proceeding.

#### Question

```
	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;
```
  - Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?
    * virtual address should be uintptr_t, see check_va2pa()

## part 3: kernel address space

#### Exercise 5. 
Fill in the missing code in mem_init() after the call to check_page().

Your code should now pass the check_kern_pgdir() and check_page_installed_pgdir() checks.

#### Question

Entry | Base Virtual Address | Points to (logically):
----- | -------------------- | ----------------------
1023 | ? | Page table for top 4MB of phys memory
1022 | ? | ?
. | ? | ?
. | ? | ?
. | ? | ?
2 | 0x00800000 | ?
1 | 0x00400000 | ?
0 | 0x00000000 | [see next question]

  - What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible.
  - We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?
  - What is the maximum amount of physical memory that this operating system can support? Why?
 How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?
  - Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

#### challenge
